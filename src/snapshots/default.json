{"scene":{"shaderGraph":{"uuid":"75167870-f0c2-11ea-a2d8-6bb496708d88","nodes":{"add_75169f80-f0c2-11ea-a2d8-6bb496708d88":{"uuid":"add_75169f80-f0c2-11ea-a2d8-6bb496708d88","name":"UV","data":{"name":"UV","inputs":[],"outputs":["out"],"uniforms":[{"name":"bSquare","elements":[{"name":"","value":false}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n    ","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition,1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n    gl_Position = positionVec4;\n}\n    ","frag":"varying vec2 vTexCoord; uniform vec2 resolution;\nuniform bool bSquare;\nvoid main() {\n    vec3 color = vec3(0.0);\n    float aspect = resolution.y/resolution.x;\n    vec2 uv = vTexCoord;\n    if(bSquare) {\n        uv.y *= aspect;\t    \n    }\n    gl_FragColor = vec4(uv.x,uv.y,1.0,1.0);\n}\n\t"},"branch_index":0,"children":["77db3dc0-f0c2-11ea-a2d8-6bb496708d88"],"parents":[],"selected":true,"coordinates":{"x":0,"y":3}},"77db3dc0-f0c2-11ea-a2d8-6bb496708d88":{"uuid":"77db3dc0-f0c2-11ea-a2d8-6bb496708d88","name":"Glyph","data":{"name":"Glyph","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"dimensions","elements":[{"name":"x:","value":100},{"name":"y:","value":100}]},{"name":"scale","elements":[{"name":"x:","value":3},{"name":"y:","value":1}]},{"name":"padding","elements":[{"name":"x:","value":0.1},{"name":"y:","value":0.1}]},{"name":"offset","elements":[{"name":"x:","value":0},{"name":"y:","value":0}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t    vTexCoord = aTexCoord;\n\n\t\t    vec4 positionVec4 = vec4(aPosition,1.0);\n\t\t    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n\n\t\t    gl_Position = positionVec4;\n\t\t}\n\t","frag":"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) +\n        i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tuniform sampler2D tex0;\n\t\tuniform vec2 resolution; // {\"name\":\"sys\"}\n\t\tuniform vec2 dimensions; // {\"name\":\"dim\",\"default\":[100.0,100.0]}\n\t\tuniform vec2 scale; \t // {\"name\":\"sc\",\"default\":[3,1]}\n\t\tuniform vec2 padding; \t // {\"name\":\"pad \",\"default\":[0.1,0.1]}\n\t\tuniform vec2 offset;     // {\"name\":\"off\",\"default\":[0.0,0.0]}\n\n\t\tvec2 gridCoordinates(vec2 uv, vec2 dim) {\n\t\t    // not sure why dim-1.\n\t\t    vec2 g = floor(uv * dim) / (dim-1.);\n\n\t\t    return g;\n\t\t}\n\n\t\tvec2 modCoordinates(vec2 uv, vec2 dim) {\n\t\t    float s_x = mod(uv.x, 1.0 / dim.x)/(1.0/dim.x);\n\t\t    float s_y = mod(uv.y, 1.0 / dim.y)/(1.0/dim.y);\n\n\t\t    return vec2(s_x,s_y);\n\t\t}\n\n\t\tfloat linearPosition(vec2 uv, vec2 dim){\n\t\t\tfloat x_pos = mod(uv.x,1.0/dim.x);\n\t\t\tfloat y_pos = mod(uv.y,1.0/dim.y);\n\n\t\t\treturn x_pos;\n\t\t}\n\n\t\tvoid main() {\n\t\t    vec3 color = vec3(0.0);\n\t\t    vec4 src = texture2D(tex0, vTexCoord);\n\t\t    \n\t\t    vec2 m_grid = modCoordinates(src.rg,dimensions);\n\t\t    vec2 grid = gridCoordinates(m_grid,dimensions);\n\t\t    float seed = linearPosition(src.rg,dimensions);\n\n\t\t    float n = snoise(vec3((grid+offset)*scale,seed));    \n\n\t\t\tcolor = vec3(n);\n\t\t\t// color = vec3(grid,0.0);\n\n\t\t    gl_FragColor = vec4(color,1.0);\n\t\t}\n\t"},"branch_index":0,"children":["7a527f50-f0c2-11ea-a2d8-6bb496708d88"],"parents":["add_75169f80-f0c2-11ea-a2d8-6bb496708d88"],"selected":true,"coordinates":{"x":0,"y":2}},"7a527f50-f0c2-11ea-a2d8-6bb496708d88":{"uuid":"7a527f50-f0c2-11ea-a2d8-6bb496708d88","name":"Add","data":{"name":"Add","inputs":["tex0","tex1"],"outputs":["out"],"uniforms":[],"precision":"\n#ifdef GL_ES\nprecision highp float;\n#endif \n","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}\n","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\nuniform vec2 resolution;\n\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    vec4 src1 = texture2D(tex1,vTexCoord);\n    vec4 color = src0 + src1;\n    gl_FragColor = color;\n}\n"},"branch_index":0,"children":["7c670770-f0c2-11ea-a2d8-6bb496708d88"],"parents":["77db3dc0-f0c2-11ea-a2d8-6bb496708d88","7c66e060-f0c2-11ea-a2d8-6bb496708d88"],"selected":true,"coordinates":{"x":0,"y":1}},"7c66e060-f0c2-11ea-a2d8-6bb496708d88":{"uuid":"7c66e060-f0c2-11ea-a2d8-6bb496708d88","name":"Noise","data":{"name":"Noise","inputs":[],"outputs":["out"],"uniforms":[{"name":"offset","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]},{"name":"seed","elements":[{"name":"","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t    vTexCoord = aTexCoord;\n\n\t\t    vec4 positionVec4 = vec4(aPosition,1.0);\n\t\t    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n\n\t\t    gl_Position = positionVec4;\n\t\t}\n\t","frag":"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) +\n        i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvarying vec2 vTexCoord;\n\nuniform vec2 offset;\nuniform float seed;\t\t\n\nvoid main() {\n    vec3 color = vec3(0.0);\n\n    float n = snoise(vec3(vec2(vTexCoord.x+offset.x,vTexCoord.y+offset.y),seed));    \n\n    color = vec3(n);\n\n    gl_FragColor = vec4(color,1.0);\n}"},"branch_index":1,"children":["7a527f50-f0c2-11ea-a2d8-6bb496708d88"],"parents":[],"selected":true,"coordinates":{"x":1,"y":2}},"7c670770-f0c2-11ea-a2d8-6bb496708d88":{"uuid":"7c670770-f0c2-11ea-a2d8-6bb496708d88","name":"next","branch_index":0,"children":[],"parents":["7a527f50-f0c2-11ea-a2d8-6bb496708d88"],"selected":true,"coordinates":{"x":0,"y":0}}},"selectedNode":"7c670770-f0c2-11ea-a2d8-6bb496708d88","coord_bounds":{"x":1,"y":3},"updateFlag":false},"targets":[]},"openPanels":["Debug","Shader Graph","Shader Controls"],"shader_collection":{"path":"/home/aceslowman/.config/camogen/shaders","name":"shaders","size":35092,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Color","name":"Color","size":2825,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Color/Blue","name":"Blue","size":606,"type":"file","extension":"","data":{"name":"Blue","inputs":["tex0"],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    gl_FragColor = vec4(0.0, 0.5, 1.0, 1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Color/Pink","name":"Pink","size":606,"type":"file","extension":"","data":{"name":"Pink","inputs":["tex0"],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Color/ToHSV","name":"ToHSV","size":1005,"type":"file","extension":"","data":{"name":"2HSV","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n    attribute vec3 aPosition;\n    attribute vec2 aTexCoord;\n    varying vec2 vTexCoord;\n    void main() {\n        vTexCoord = aTexCoord;\n        vec4 positionVec4 = vec4(aPosition,1.0);\n        positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n        gl_Position = positionVec4;\n    }\n\t","frag":"\n    varying vec2 vTexCoord;\n    uniform sampler2D tex0;\n    uniform vec2 resolution;\n    \n    uniform float scale;\n    uniform float rotation;\n\n    vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    void main() {\n        vec4 c = texture2D(tex0, vTexCoord);\n\n        vec3 hsv = scale * c.rgb;        \n\n        gl_FragColor = vec4(hsv2rgb(hsv + vec3(rotation, 0., 0.)), 1.0);\n    }\n\t"}},{"path":"/home/aceslowman/.config/camogen/shaders/Color/Yellow","name":"Yellow","size":608,"type":"file","extension":"","data":{"name":"Yellow","inputs":["tex0"],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    gl_FragColor = vec4(1.0, 1.0, 0.5, 1.0);\n}"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Debug","name":"Debug","size":3163,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Debug/Debug","name":"Debug","size":3163,"type":"file","extension":"","data":{"name":"Debug","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"float_one","elements":[{"value":0.453}]},{"name":"vector_two","elements":[{"value":1},{"value":1}]},{"name":"vector_three","elements":[{"value":1},{"value":1},{"value":1}]},{"name":"boolOne","elements":[{"value":true}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"uniform vec2 resolution;\nuniform float float_one; //{\"default\": 0.453}\nuniform vec2 vector_two;\nuniform vec3 vector_three;\nuniform bool boolOne; //{\"default\": true}\nvarying vec2 vTexCoord;\n\nvoid main() {\n    gl_FragColor = vec4(float_one,0.0,0.3,boolOne);\n}"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Default","name":"Default","size":798,"type":"file","extension":"","data":{"name":"ToHSV","inputs":[],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]},{"name":"scale","elements":[{"name":"","value":1}]},{"name":"rotation","elements":[{"name":"","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Generators","name":"Generators","size":7864,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Generators/Default","name":"Default","size":798,"type":"file","extension":"","data":{"name":"ToHSV","inputs":[],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]},{"name":"scale","elements":[{"name":"","value":1}]},{"name":"rotation","elements":[{"name":"","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Generators/Noise","name":"Noise","size":5795,"type":"file","extension":"","data":{"name":"Noise","inputs":[],"outputs":["out"],"uniforms":[{"name":"seed","elements":[{"name":"","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t    vTexCoord = aTexCoord;\n\n\t\t    vec4 positionVec4 = vec4(aPosition,1.0);\n\t\t    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n\n\t\t    gl_Position = positionVec4;\n\t\t}\n\t","frag":"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) +\n        i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nvarying vec2 vTexCoord;\n\nuniform vec2 offset;\nuniform float seed;\t\t\n\nvoid main() {\n    vec3 color = vec3(0.0);\n\n    float n = snoise(vec3(vec2(vTexCoord.x+offset.x,vTexCoord.y+offset.y),seed));    \n\n    color = vec3(n);\n\n    gl_FragColor = vec4(color,1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Generators/UV","name":"UV","size":1271,"type":"file","extension":"","data":{"name":"UV","inputs":[],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]},{"name":"bSquare","elements":[{"name":"","value":false}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n    ","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition,1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n    gl_Position = positionVec4;\n}\n    ","frag":"varying vec2 vTexCoord; uniform vec2 resolution;\nuniform bool bSquare;\nvoid main() {\n    vec3 color = vec3(0.0);\n    float aspect = resolution.y/resolution.x;\n    vec2 uv = vTexCoord;\n    if(bSquare) {\n        uv.y *= aspect;\t    \n    }\n    gl_FragColor = vec4(uv.x,uv.y,1.0,1.0);\n}\n\t"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Image","name":"Image","size":3099,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Image/Invert","name":"Invert","size":841,"type":"file","extension":"","data":{"name":"Invert","inputs":[],"outputs":["out"],"uniforms":[{"name":"amount","elements":[{"name":"","value":"1"}]}],"precision":"\n#ifdef GL_ES\nprecision highp float;\n#endif \n","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}\n","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nuniform float amount;\n\nvoid main() {\n    vec4 src = texture2D(tex0, vTexCoord);        \n\n    vec3 color = amount - src.rgb;\n\n    gl_FragColor = vec4(color,src.a);\n}\n"}},{"path":"/home/aceslowman/.config/camogen/shaders/Image/Sharpen","name":"Sharpen","size":1216,"type":"file","extension":"","data":{"name":"Sharpen","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n#ifdef GL_ES\nprecision highp float;\n#endif \n","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\n\nuniform vec2 resolution;\nuniform float width;\nvarying vec2 texcoord11;\nvarying vec2 texcoord00;\nvarying vec2 texcoord02;\nvarying vec2 texcoord20;\nvarying vec2 texcoord22;\nvoid main() {\n    gl_Position = vec4(((aPosition.xy / resolution) * 2.0 - 1.0) * vec2(1.0, -1.0), 0.0, 1.0);\n    texcoord11 = aTexCoord;\n    texcoord00 = aTexCoord + vec2(-width, -width);\n    texcoord02 = aTexCoord + vec2(width, -width);\n    texcoord20 = aTexCoord + vec2(width, width);\n    texcoord22 = aTexCoord + vec2(-width, width);\n}","frag":"varying vec2 texcoord11;\nvarying vec2 texcoord00;\nvarying vec2 texcoord02;\nvarying vec2 texcoord20;\nvarying vec2 texcoord22;\n\nuniform sampler2D tex0;\n\nvoid main() {\t\n    vec4 s11 = texture2D(tex0, texcoord11);\n    vec4 s00 = texture2D(tex0, texcoord00);\n    vec4 s02 = texture2D(tex0, texcoord02);\n    vec4 s20 = texture2D(tex0, texcoord20);\n    vec4 s22 = texture2D(tex0, texcoord22);\n    \n    vec4 sharp = 5.0 * s11 - (s00 + s02 + s20 + s22);\n    gl_FragColor = sharp;\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Image/Threshold","name":"Threshold","size":1042,"type":"file","extension":"","data":{"name":"Threshold","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n#ifdef GL_ES\nprecision highp float;\n#endif \n","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}\n","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nuniform float low;\nuniform float high;\nuniform bool b_invert;\n\n// https://github.com/hughsk/glsl-luma/blob/master/index.glsl\nfloat luma(vec3 color) {\nreturn dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\nreturn dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nvoid main() {\n    vec4 src = texture2D(tex0, vTexCoord);        \n    \n    bool thresh = (luma(src) > low) && (luma(src) < high);\n\n    vec3 color = vec3(0.0);\n\n    if(thresh){\n        color = vec3(1.0);\n    }\n\n    gl_FragColor = vec4(color.rgb,src.a);\n}"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Math","name":"Math","size":2530,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Math/Add","name":"Add","size":643,"type":"file","extension":"","data":{"name":"Add","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n#ifdef GL_ES\nprecision highp float;\n#endif \n","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}\n","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\nuniform vec2 resolution;\n\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    vec4 src1 = texture2D(tex1,vTexCoord);\n    vec4 color = src0 + src1;\n    gl_FragColor = color;\n}\n"}},{"path":"/home/aceslowman/.config/camogen/shaders/Math/Divide","name":"Divide","size":628,"type":"file","extension":"","data":{"name":"Divide","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\n\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    vec4 src1 = texture2D(tex1,vTexCoord);\n    vec4 color = src0 / src1;\n    gl_FragColor = color;\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Math/Multiply","name":"Multiply","size":629,"type":"file","extension":"","data":{"name":"Multiply","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\n\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    vec4 src1 = texture2D(tex1,vTexCoord);\n    vec4 color = src0 * src1;\n    gl_FragColor = color;\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Math/Subtract","name":"Subtract","size":630,"type":"file","extension":"","data":{"name":"Subtract","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\n\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    vec4 src1 = texture2D(tex1,vTexCoord);\n    vec4 color = src0 - src1;\n    gl_FragColor = color;\n}"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Simple","name":"Simple","size":757,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Simple/Wavy","name":"Wavy","size":757,"type":"file","extension":"","data":{"name":"Wavy","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t    vTexCoord = aTexCoord;\n\n\t\t    vec4 positionVec4 = vec4(aPosition,1.0);\n\t\t    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n\n\t\t    gl_Position = positionVec4;\n\t\t}\n\t","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\n\nuniform float scale;\nuniform float frequency;\nuniform float time;\n\nvoid main() {\n    vec2 uv = vTexCoord;\n\n    uv.y +=  sin(time + (uv.x * frequency)) * scale;\n\n    vec4 c = texture2D(tex0, uv);\n\n    gl_FragColor = c;\n} "}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Special","name":"Special","size":9727,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Special/Glyph","name":"Glyph","size":6711,"type":"file","extension":"","data":{"name":"Glyph","inputs":[],"outputs":["out"],"uniforms":[],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n\t\tattribute vec3 aPosition;\n\t\tattribute vec2 aTexCoord;\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tvoid main() {\n\t\t    vTexCoord = aTexCoord;\n\n\t\t    vec4 positionVec4 = vec4(aPosition,1.0);\n\t\t    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n\n\t\t    gl_Position = positionVec4;\n\t\t}\n\t","frag":"\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i = floor(v + dot(v, C.yyy));\n    vec3 x0 = v - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0)) +\n            i.y + vec4(0.0, i1.y, i2.y, 1.0)) +\n        i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3 ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)\n\n    vec4 x = x_ * ns.x + ns.yyyy;\n    vec4 y = y_ * ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 p0 = vec3(a0.xy, h.x);\n    vec3 p1 = vec3(a0.zw, h.y);\n    vec3 p2 = vec3(a1.xy, h.z);\n    vec3 p3 = vec3(a1.zw, h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),\n        dot(p2, x2), dot(p3, x3)));\n}\n\nvec2 mod289(vec2 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0\n        0.366025403784439, // 0.5*(sqrt(3.0)-1.0)\n        -0.577350269189626, // -1.0 + 2.0 * C.x\n        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n    //i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) +\n        i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m * m;\n    m = m * m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt( a0*a0 + h*h );\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g;\n    g.x = a0.x * x0.x + h.x * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n\t\tvarying vec2 vTexCoord;\n\n\t\tuniform sampler2D tex0;\n\t\tuniform vec2 resolution; // {\"name\":\"sys\"}\n\t\tuniform vec2 dimensions; // {\"name\":\"dim\",\"default\":[100.0,100.0]}\n\t\tuniform vec2 scale; \t // {\"name\":\"sc\",\"default\":[3,1]}\n\t\tuniform vec2 padding; \t // {\"name\":\"pad \",\"default\":[0.1,0.1]}\n\t\tuniform vec2 offset;     // {\"name\":\"off\",\"default\":[0.0,0.0]}\n\n\t\tvec2 gridCoordinates(vec2 uv, vec2 dim) {\n\t\t    // not sure why dim-1.\n\t\t    vec2 g = floor(uv * dim) / (dim-1.);\n\n\t\t    return g;\n\t\t}\n\n\t\tvec2 modCoordinates(vec2 uv, vec2 dim) {\n\t\t    float s_x = mod(uv.x, 1.0 / dim.x)/(1.0/dim.x);\n\t\t    float s_y = mod(uv.y, 1.0 / dim.y)/(1.0/dim.y);\n\n\t\t    return vec2(s_x,s_y);\n\t\t}\n\n\t\tfloat linearPosition(vec2 uv, vec2 dim){\n\t\t\tfloat x_pos = mod(uv.x,1.0/dim.x);\n\t\t\tfloat y_pos = mod(uv.y,1.0/dim.y);\n\n\t\t\treturn x_pos;\n\t\t}\n\n\t\tvoid main() {\n\t\t    vec3 color = vec3(0.0);\n\t\t    vec4 src = texture2D(tex0, vTexCoord);\n\t\t    \n\t\t    vec2 m_grid = modCoordinates(src.rg,dimensions);\n\t\t    vec2 grid = gridCoordinates(m_grid,dimensions);\n\t\t    float seed = linearPosition(src.rg,dimensions);\n\n\t\t    float n = snoise(vec3((grid+offset)*scale,seed));    \n\n\t\t\tcolor = vec3(n);\n\t\t\t// color = vec3(grid,0.0);\n\n\t\t    gl_FragColor = vec4(color,1.0);\n\t\t}\n\t"}},{"path":"/home/aceslowman/.config/camogen/shaders/Special/Mode7","name":"Mode7","size":983,"type":"file","extension":"","data":{"name":"Mode7","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nvoid main() {\n    vec2 warp = vTexCoord;\n    \n    warp.y *= 2.0;\n    warp.y -= 1.0;\n    warp.x *= warp.y;\n    warp.x += 0.5 * vTexCoord.y;\n    \n    vec4 src0 = texture2D(tex0,warp);\n    \n    vec4 color = src0 * vec4(warp.y);\n    color = vec4(vec3(color.rgb),1.0);\n    // vec4 color = vec4(warp.x,warp.y,0.0,1.0);\n    \n    gl_FragColor = color;\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Special/Temporal_Bind","name":"Temporal_Bind","size":2033,"type":"file","extension":"","data":{"name":"Temporal_Bind","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"rows","elements":[{"name":"","value":"6.3"}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"\n    attribute vec3 aPosition;\n    attribute vec2 aTexCoord;\n    varying vec2 vTexCoord;\n    void main() {\n        vTexCoord = aTexCoord;\n        vec4 positionVec4 = vec4(aPosition,1.0);\n        positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n        gl_Position = positionVec4;\n    }\n\t","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\nuniform float rows;\nvoid main() {\n    vec4 src0 = texture2D(tex0,vTexCoord);\n    \n    vec4 color = vec4(0.0);\n    \n    vec2 rhythm1 = vec2(mod(vTexCoord.x,0.15),mod(vTexCoord.y,1.0/rows));\n    vec4 strip1 = texture2D(tex0,rhythm1);\n    \n    vec2 rhythm2 = vec2(mod(vTexCoord.x,0.4136),mod(vTexCoord.y,1.0/rows));\n    vec4 strip2 = texture2D(tex0,rhythm2);\n    \n    vec4 sum = strip1 + strip2;\n    \n    if(vTexCoord.y < (1.0/rows)) {\n        color = vec4(src0);    \n    }else if(vTexCoord.y < (2.0/rows)) {\n        color = vec4(strip2);\n    }else if(vTexCoord.y < (3.0/rows)) {\n        //color = mix(strip1,strip2,rhythm1.x*rhythm2.x);\n        rhythm1.x += sin(rhythm1.x*1.0)*sin(rhythm2.x*2.0);\n        rhythm1.x *= 1.0;\n        color = texture2D(tex0,rhythm1);\n    }else if(vTexCoord.y < (4.0/rows)) {\n        rhythm1.x += sin(rhythm1.x*1.0)*sin(rhythm2.x*40.0);\n        rhythm1.x *= 1.0;\n        color = texture2D(tex0,rhythm1);\n    }else if(vTexCoord.y < (5.0/rows)) {\n        rhythm1.x += sin(rhythm1.x*0.2)*sin(rhythm2.x*90.0);\n        rhythm1.x *= 1.0;\n        color = texture2D(tex0,rhythm1);\n    }else if(vTexCoord.y > (5.0/rows)) {\n        rhythm1.x += sin(rhythm1.x*0.1)*sin(rhythm2.x*890.0);\n        rhythm1.x *= 1.0;\n        //rhythm1.y /= 2.0;\n        color = texture2D(tex0,rhythm1);\n    }\n        \n    \n    \n    color.a = 1.0;\n    gl_FragColor = color;\n}"}}]},{"path":"/home/aceslowman/.config/camogen/shaders/Spirit Deck","name":"Spirit Deck","size":4329,"type":"directory","children":[{"path":"/home/aceslowman/.config/camogen/shaders/Spirit Deck/The_Chariot","name":"The_Chariot","size":1775,"type":"file","extension":"","data":{"name":"The_Chariot","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\n\nvec2 rotate(vec2 st, float a) {\n    st = mat2(cos(a),-sin(a),sin(a),cos(a))*(st-0.5);\n    return st+0.5;\n}\n\nfloat flip(float v, float pct) {\n    return mix(v, 1.0 - v, pct);\n}\n\nfloat stroke(float x, float s, float w) {\n    float d = step(s,x+w*0.5) - step(s,x-w*0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nfloat fill(float x, float size) {\n    return 1.0-step(size, x);\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n    st = st*2.0-1.0;\n    return max(abs(st.x/s.x),abs(st.y/s.y));\n}\n\nvec3 bridge(vec3 c,float d,float s,float w) {\n    c *= 1.0-stroke(d,s,w*2.0);\n    return c + stroke(d,s,w);\n}\n\nvoid main() {\n    vec3 color = vec3(0.0);\n    //vec2 st = vTexCoord;\n    vec2 st = texture2D(tex0,vTexCoord).rg;\n\n    float r1 = rectSDF(st, vec2(1.0));\n    float r2 = rectSDF(rotate(st,radians(45.0)),vec2(1.0));\n    \n    float inv = step(0.5,(st.x+st.y)*0.5);\n    inv = flip(inv,step(0.5,0.5+(st.x-st.y)*0.5));\n    \n    float w = 0.075;\n    color += stroke(r1,0.5,w) + stroke(r2,0.5,w);\n    \n    float bridges = mix(r1,r2,inv);\n    color = bridge(color, bridges, 0.5, w);\n\n    gl_FragColor = vec4(color.rgb, 1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Spirit Deck/The_Empress","name":"The_Empress","size":1278,"type":"file","extension":"","data":{"name":"The_Empress","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform vec2 resolution;\n\nconst float PI = 3.1415926538;\nconst float TAU = 6.28318530718;\n\nfloat polySDF(vec2 st, int V) {\n    st = st * 2.0 - 1.0;\n    float a = atan(st.x,st.y)+PI;\n    float r = length(st);\n    float v = TAU / float(V);\n    return cos(floor(0.5+a/v)*v-a)*r;\n}\n\nfloat fill(float x, float size) {\n    return 1.-step(size, x);\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    vec2 st = vTexCoord;\n    \n    float d1 = polySDF(st,5);\n    vec2 ts = vec2(st.x,1.0-st.y);\n    float d2 = polySDF(ts,5);\n    \n    color += fill(d1,0.75) * fill(fract(d1*5.0),0.5);\n    color -= fill(d1,0.6) * fill(fract(d2*4.9),0.45);\n    \n    gl_FragColor = vec4(color.rgb,1.0);\n}"}},{"path":"/home/aceslowman/.config/camogen/shaders/Spirit Deck/The_Tower","name":"The_Tower","size":1276,"type":"file","extension":"","data":{"name":"The_Tower","inputs":["tex0"],"outputs":["out"],"uniforms":[{"name":"resolution","elements":[{"name":"x:","value":1},{"name":"y:","value":1}]}],"precision":"\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t","vert":"attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition, 1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1., -1.);\n    gl_Position = positionVec4;\n}","frag":"varying vec2 vTexCoord;\nuniform sampler2D tex0;\nuniform vec2 resolution;\n\nfloat flip(float v, float pct) {\n    return mix(v, 1.0 - v, pct);\n}\n\nfloat stroke(float x, float s, float w) {\n    float d = step(s,x+w*0.5) - step(s,x-w*0.5);\n    return clamp(d, 0.0, 1.0);\n}\n\nfloat fill(float x, float size) {\n    return 1.0-step(size, x);\n}\n\nfloat rectSDF(vec2 st, vec2 s) {\n    st = st*2.0-1.0;\n    return max(abs(st.x/s.x),abs(st.y/s.y));\n}\n\nvoid main() {\n    vec4 color = vec4(0.0);\n    vec2 st = vTexCoord;\n    float rect = rectSDF(st, vec2(0.5,1.0));\n    float diag = (st.x+st.y)*0.5;\n    color  +=  flip(fill(rect,0.6),stroke(diag,0.5,0.01));\n    \n    gl_FragColor = vec4(vec3(color.rgb), 1.0);\n}"}}]}]},"ready":true}
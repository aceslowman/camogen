{
  "type": "Shader",
  "name": "EdgeDetect",
  "precision": "#ifdef GL_ES \n   precision highp float; \n#endif \n",
  "vert": "attribute vec3 aPosition; \nattribute vec2 aTexCoord; \nvarying vec2 vTexCoord; \n\nvoid main() {  \n   vTexCoord = aTexCoord; \n   vec4 positionVec4 = vec4(aPosition, 1.0); \n   positionVec4.xy = positionVec4.xy * vec2(1., -1.); \n   gl_Position = positionVec4; \n}",
  "frag": "uniform sampler2D tex0;\nuniform vec2 resolution;\n\n// Texture varyings\nvarying vec2 vTexCoord;\n\nuniform float amount;\n\n/*\n * The main program\n */\nvoid main() {\n    // Calculate the pixel color based on the mouse position\n    vec3 pixel_color;\n  \tvec2 v_uv = vTexCoord;\n\n    // Apply the edge detection kernel\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(-1, -1) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(-1, 0) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(-1, 1) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(0, -1) / resolution).rgb;\n    pixel_color += 8.0 * texture2D(tex0, v_uv + vec2(0, 0) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(0, 1) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(1, -1) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(1, 0) / resolution).rgb;\n    pixel_color += -1.0 * texture2D(tex0, v_uv + vec2(1, 1) / resolution).rgb;\n\n    // Use the most extreme color value\n    float min_value = min(pixel_color.r, min(pixel_color.g, pixel_color.b));\n    float max_value = max(pixel_color.r, max(pixel_color.g, pixel_color.b));\n\n    if (abs(min_value) > abs(max_value)) {\n        pixel_color = vec3(min_value);\n    } else {\n        pixel_color = vec3(max_value);\n    }\n\n    // Rescale the pixel color using the mouse y position\n    float scale = 0.2 + 2.5 * amount;\n    pixel_color = 0.5 + scale * pixel_color;\n\n    // Fragment shader output\n    gl_FragColor = vec4(pixel_color, 1.0);\n}"
}

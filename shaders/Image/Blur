{
  "type": "Shader",
  "name": "Blur",  
  "precision": "\n\t\t#ifdef GL_ES\n\t\tprecision highp float;\n\t\t#endif \n\t",
  "vert": "attribute vec3 aPosition;\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n    vTexCoord = aTexCoord;\n    vec4 positionVec4 = vec4(aPosition,1.0);\n    positionVec4.xy = positionVec4.xy * vec2(1.,-1.);\n    gl_Position = positionVec4;\n}\n\t",
  "frag": "// adapted from https://webgl-shaders.com/shaders/frag-blur.glsl\nuniform vec2 resolution;\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float size;\n\nvoid main() {\n  vec3 color;\n  vec2 uv = vTexCoord;\n\n  // Apply the gaussian kernel\n  float step = 1.0 + 2.0 * size;\n  color += (1.0 / 256.0) * texture2D(tex0, uv + step * vec2(-2, -2) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(-2, -1) / resolution).rgb;\n  color += (6.0 / 256.0) * texture2D(tex0, uv + step * vec2(-2, 0) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(-2, 1) / resolution).rgb;\n  color += (1.0 / 256.0) * texture2D(tex0, uv + step * vec2(-2, 2) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(-1, -2) / resolution).rgb;\n  color += (16.0 / 256.0) * texture2D(tex0, uv + step * vec2(-1, -1) / resolution).rgb;\n  color += (24.0 / 256.0) * texture2D(tex0, uv + step * vec2(-1, 0) / resolution).rgb;\n  color += (16.0 / 256.0) * texture2D(tex0, uv + step * vec2(-1, 1) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(-1, 2) / resolution).rgb;\n  color += (6.0 / 256.0) * texture2D(tex0, uv + step * vec2(0, -2) / resolution).rgb;\n  color += (24.0 / 256.0) * texture2D(tex0, uv + step * vec2(0, -1) / resolution).rgb;\n  color += (36.0 / 256.0) * texture2D(tex0, uv + step * vec2(0, 0) / resolution).rgb;\n  color += (24.0 / 256.0) * texture2D(tex0, uv + step * vec2(0, 1) / resolution).rgb;\n  color += (6.0 / 256.0) * texture2D(tex0, uv + step * vec2(0, 2) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(1, -2) / resolution).rgb;\n  color += (16.0 / 256.0) * texture2D(tex0, uv + step * vec2(1, -1) / resolution).rgb;\n  color += (24.0 / 256.0) * texture2D(tex0, uv + step * vec2(1, 0) / resolution).rgb;\n  color += (16.0 / 256.0) * texture2D(tex0, uv + step * vec2(1, 1) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(1, 2) / resolution).rgb;\n  color += (1.0 / 256.0) * texture2D(tex0, uv + step * vec2(2, -2) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(2, -1) / resolution).rgb;\n  color += (6.0 / 256.0) * texture2D(tex0, uv + step * vec2(2, 0) / resolution).rgb;\n  color += (4.0 / 256.0) * texture2D(tex0, uv + step * vec2(2, 1) / resolution).rgb;\n  color += (1.0 / 256.0) * texture2D(tex0, uv + step * vec2(2, 2) / resolution).rgb;\n\n  // Fragment shader output\n  gl_FragColor = vec4(color, 1.0);\n}"
}
